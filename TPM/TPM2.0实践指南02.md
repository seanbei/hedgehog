# 第二章 基本的安全概念
本章主要讲安全概念的概况及其在 `TPM` 中的应用。这些概念中有一些潜在的数学方法，对你来说并不用掌握，所以这里不会提到它们。相反，本章主要讨论各种加密算法的表象，帮助你了解这些算法在 `TPM` 规范中是如何使用的。

安全专家们可以跳过这一章。如果你以前学过一点安全知识，或者已经生疏，建议你进行略读，以唤醒你的记忆，也能了解基本的加密算法在 `TPMs` 是怎么用的。如果你压根不知道 `TPM` 是啥，那本章是必读的。

`TPM 2.0` 中包含的所有加密算法都基于已被广泛审查的公共标准。创建自定义的强加密算法一般来说是非常困难的。在一个算法被社区公认为强大之前，必须经过多年的密码分析，只有那些符合标准的算法，才能被可信计算组织（`TCG`）批准使用到 `TPM` 中。在本章中，描述了三种算法：用于完整性的哈希算法、用于机密性的对称加密算法以及用于数字签名和密钥管理的非对称加密算法。特别地，我们会探索安全哈希算法：高级加密标准(`AES`)，两个非对称的标准：`RSA` 和椭圆曲线密码(`ECC`)。但是在讨论实际算法之前，需要知道它们被用来防御什么。

本章首先描述了两种攻击类型：暴力攻击和密码分析。然后定义了一些基本概念：消息、保密、完整性、身份验证和授权，以及两个更高层次的概念：反重放和不可抵赖性。最后列出了 `TPM` 中使用的加密算法类。

这些大部分都是通用的安全准则，在 `TPM` 设计中贯穿使用。它们在 `TPM 2.0` 的具体应用，在本书前后都会提到。在少数情况下，`TPM` 使用了非通用的加密方法，规范中有些地方介绍了新的加密术语，我们都会进行说明。（扩展操作就是这两种情况的一个例子：它是一个通用的安全概念，已经以一种新的方式应用在 `TPM` 中。）

`TPM` 中所做的一切在某种程度上都与减轻密码攻击有关。

## 密码攻击
加密是为了防止攻击者做恶意的事情。使用加密的安全系统被设计用于阻止坏人获取你的数据、仿造你、进行不被察觉的文档修改。这些攻击者试图破坏加密设计的安全性，有两种基本的方式：一是通过深入理解数学算法和协议，使用这些知识来寻找和利用设计中的漏洞，二是使用暴力破解。

如果你用的是良好审查过的算法与协议，而且是按着他们设计的方式使用的，那么，你的设计就不会受第一类攻击的影响。因此，你要多注意，应该使用已被接纳的算法与协议。而在暴力破解中，攻击者会尝试各种可能的密钥、输入及密码，来猜测为了保护设计而使用的加密。

### 暴力破解
密码学家不喜欢说一切都是不可能的，相反，他们会说“计算上不可行”，就是说，要尝试每种组合来攻击密码学所花费的时间，是不切实际的。在数据加密标准（`DES`）中，`2^56^` 种密钥会被用到，这个数字很大，是 `72,057,594,037,927,936`。破解 `DES` 算法看起来是计算上不可行的，然而，在 `1988` 年，有人发明了一台机器，做到了。[^1]

密码经常遭到暴力破解，先从字典中的单词开始尝试，然后是单词加数字，甚至还有特殊字符。攻击者甚至会使用克林贡单词，以及哈利波特或指环王中的单词！[`RainbowCrack`](www.project-rainbowcrack.com/) 是一个非常有名的程序，可以暴力破解更长的密码。

如果算法的强度不依赖于算法的保密程度，那么这个加密算法就是很好的。如果真是这样，那么它就很难被破解，如果很难被破解，通常就被叫做密钥。防御暴力破解，就是要让密钥足够长，使得很难遍历，或者减少在一段时间内被攻击的次数。

`TCG` 假设它批准的所有算法都是良好设计的。这并不一定正确，因为该规范不遵循特定算法, 如果有一个算法在未来被发现了弱点，规范并不会被重写，只会把这个算法从已批准的算法列表中移除。

经过良好设计的算法的强度，是通过它对数学攻击的免疫强度来测量的。强度的实现，依赖于算法的类型以及密钥的长度 。

[^1]: http://en.wikipedia.org/wiki/Data_Encryption_Standard#Chronology.


#### 通过`类型`计算算法强度

对称算法用于传统加密，其中用于加密和解密的密钥是相同的。对于设计良好的对称算法，加密算法的强度是以指数级依赖于密钥的长度。由此，如果一个密钥只有 `4` 位的长度，那么它就有 `24` 或 `16` 种可能。使用暴力破解的攻击者，只要把这 `16` 种可能全部尝试一遍，就可以破解密码。其实，平均下来，攻击者只需尝试一半，也就是 `8` 次，就可以找到正确的密钥了。由于指数级的数字很大，算法的强度通常以比特表示。设计良好的对称算法的强度等于其密钥中的位数。在 `TPM` 中，对称算法通常使用 `128、192` 或 `256` 位的密钥。

安全哈希算法像是一种只加密但不解密的算法。这听上去好像没什么用，但其实有很多有意思的用处。安全哈希算法总是生成相同大小的输出，而不依赖于输入。给定一个输入，你总是会得到相同的输出。但是，给定一个输出，你是无法计算输入的。这种算法的强度可以用两种方式来计算：
- 给定一个哈希输出，找到其**对应的输入**所需要尝试的次数。对于设计良好的哈希算法，这被假定为该输出的位长度。
- `50%` 概率找到同一个输出的两个输入，所需要尝试的次数。对于设计良好的哈希算法，它就是该输出的位长度的一半。[^2]

根据安全哈希的用法，上面两种都是正确的。但是，由于密码学者都是 `P3` 人（付费专业达人），第二种更普遍地用于设计良好的安全哈希算法的强度。

非对称算法在首次介绍时会显得很奇怪：加密算法跟解密算法是不一样的，两者使用不同的密钥，包括不同的公钥密钥对。你需要关注两种非对称算法，本章会在后面讲到：`RSA`（以发明者的名字首字母组成：`Rivest`、`Shamir`、`Adleman`）和椭圆曲线密码（`ECC`）。

对于非对称算法来说，依据一个专有的密钥长度，是很难计算强度的。比如 `RSA`，你可以查阅一些表格。这些表格中提到RSA非对称密钥的 `2048` 位对应于对称密钥中的 `112` 位的强度，而 `3076` 位则对应于 `128` 位，`15360` 位对应于 `256` 位。而对于 `ECC`，它的强度则被认为是其密钥长度的一半。因此，`256` 位的 `ECC` 密钥，其强度跟 `128` 位的对称密钥是一样的，而一个 `384` 位的 `ECC` 密钥，则对应于 `192` 位的对称密钥。

如果密钥长度很长，暴力破解不可行，攻击者就会尝试分析加密算法或协议的数学方法，以期望找到一条捷径。

[^2]: 这种攻击通常被称为生日攻击，源于一种古老的派对把戏。如果一个房间里有 `23` 人（接近 `365` 的平方根），其中 `2` 人有机会同一个生日的概率是 `50%`。如果房间里有更多的人，概率会上升。如果有 `40` 个人，概率几乎是 `90%`。

### 攻击算法本身

密码算法设计是一门艺术。使用的数学需要基于要解决特定类型问题的难度，而这种难度又是基于当前已有的知识。很难设计一种永远无法发起攻击的算法。

`SHA-1` 哈希算法遭到攻击[^3]，成为了 `TPM 1.2` 向 `TPM 2.0` 发展的契机。在常规环境下，暴力破解生日攻击 `SHA-1` 需要 `2^80^` 次计算，密码强度是 `80`。而这次攻击基于数学中潜在的一个漏洞，成功地将破解所需的计算次数降低到 `2^63^` 次（密码强度为 `63`）。`TMP 1.2` 正好在设计中使用了 `SHA-1`。随着 `56` 位 `DES` 加密在 `1998` 年被暴力破解成功，`63` 位密码强度对行业来说显然是不够的。于是，`TPM 2.0` 将 `SHA-1` 算法移除了。为了防止此类攻击事件再次发生，大家决定使用敏捷的方式来管理算法，算法可以在 `TPM` 规范中新增或删除，这样就不用重新制定整个规范了。

总之，为了保证安全，加密算法需要注意以下事项：
- 算法中的弱点：避免使用较弱的算法，而要使用经过严格审查、为国际广泛接受的标准。
- 针对暴力攻击：选择长密钥，如今，`128` 位通常被认为是对称算法的安全值，但一些研究人员和安全机构坚持使用 `192` 位。

好了，现在你已经了解了所要防御的攻击，我们接下来就可以讨论 `TPM` 规范中使用的基本密码结构了。我们从一些定义开始。

[^3]: Xiaoyun Wang, Yiqun Lisa Yin, and Hongbo Yu, “Finding Collisions in the Full SHA-1,” Advances in Cryptology–CRYPTO 2005.

## 安全中的定义

要理解 `TPM` 架构和加密概念，有一些定义很重要。人们通常会简单的把安全等同于保密性，也就是说攻击者无法解译一条秘密消息。然而，保密确实很重要，但安全绝不仅仅是这些。为了方便理解，我们最好还是从例子着手。而电子商务在 `TPM` 设计中起了很大的推动作用，下面我们就拿电子商务的例子来说。

在电子商务中，一个电子订单由买家传递到卖家手中，双方都会希望采购信息是保密的，如信用卡号等。同时，他们还想确保以下几个事情：
- 订单是来自真正的买家，而不是一个网络攻击者，
- 订单只会发给卖家，而不是其他人，
- 在传送过程中信息不会被修改（如采购金额），
- 订单只会发送一次，不会被阻塞，也不会发送多次。
最后，卖家需要确认买家是承诺购买的，而且是按照订单的采购金额来支付。加密和安全协议，正是用于解决以上所有涉及的地方。

基于上面的例子，我们来描述常用的安全术语和概念，然后
- **消息**：双方之间发送的一个字节数组。
- **保密**：防止未经授权的人看到消息的内容而采取的措施。
- **共享秘密**：只有双方知道的值，这个秘密可以是一个简单的密码，也可以是双方都知道的一个密钥。
- **完整性**：指示消息在存储或传输过程中未被修改。
- **认证**：消息绑定到创建者一种方式，用于接收者验证该消息。
- **授权**：允许用户执行某项操作的证据。
- **反重放**：防止攻击者重复使用一条有效的消息。
- **不可抵赖性**：防止消息的发送者说自己没有发送。

我们逐个来看它们是怎么用在上面的电子采购订单里的。**消息**就是指订单的编号以及所有的用户保密信息，如信用卡号。**完整性**就是指订单的内容在传输时没有被修改，如原本是 `3` 个，却被改成了 `300` 个。**认证**确保了订单是来自真正的买家的。**授权**保证了买家是以公司的名义来购买的。**反重放**阻止了攻击者重发买家消息来多次购买。**不可抵赖性**则是指买家无法否认自己下过订单。

为了提供这些安全保障，安全系统的设计者会使用一系列已经被完整开发、验证及标准化的加密工具。有一些是基础数学构建的模块，如 `SHA-256` 安全哈希算法与 `RSA` 非对称加密算法。另一些，则是在此基础上使用 `RSA` 算法构建的数字签名。这些加密功能会在后面慢慢道来。


## 加密族谱

相信我们，本章不会涉及数学。我们不会讲素数算法和椭圆曲线。但是，非常有必要讲一些加密操作，这样才能与你前面学到的内容串联起来。

安全哈希算法用于提供**完整性**。它联合了 `HMAC` 算法中的**共享秘密**签名密钥，来确保**认证**无误。`HMAC` 又是加密票据和密钥派生功能的基础。在对称密钥加密中，**共享秘密**提供了**保密性**。随机数值提供了**反重放**保护。使用非对称密钥作为签名密钥提供了**不可抵赖性**。在某些协议中，`TPM` 还会使用非对称密钥来确保**保密性**。所有这些概念都会在下面讲到。


### 安全哈希 Hash（或摘要 Digest）

大部分计算机科学的学生都很熟悉哈希，简单的哈希常用于加速搜索。而更高级的形式，那就是校验和（`checksum`），用于检测数据中的随机错误。而密码学家担心的则是那些试图破坏系统的恶意攻击者，因此他们需要的是一种具有特定属性的安全加密哈希。

跟很多类似的简单哈希相似，密码学中的哈希获取一条任意长度的消息，将它压缩到一段固定长度的哈希。例如，`SHA-256` 压缩后的哈希为 `256` 比特，也就是 `32` 字节。出于安全考量，安全哈希算法有如下重要属性：
- 给定一条消息，无法用它的哈希值构建另一条消息。
- 无法用同一个哈希值构建两条消息
- 无法通过哈希值来反推消息

下面的例子，你会发现，消息体中很小的改动，会导致哈希值的巨大变化。使用 `SHA-1` 可以得到 `Hello` 的哈希值为：
```
fedd18797811a4af659678ea5db618f8dc91480b
```
而 `hello` 的哈希值为：
```
aa5916ae7fd159a18b1b72ea905c757207e26689
```
看到没有，只是首字母大小写的改变，它们的哈希值完全不一样了。

`TPM 2.0` 允许使用各种各样的的哈希算法——`SHA-1`、`SHA-256`、`SHA-384` 只是其中的几个而已。实际上，人们在 TPM 上只实现了典型的几个算法。有个问题困扰了开发者很长一段时间，那就是如何集成多个哈希算法以维持完整性，一旦其中一个在将来被破解，就很麻烦了。 